<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title></title>
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css" />
    <script type="module" src="Javascript/main.js"></script>
  </head>
  <body>
    <main>
      <nav>
        <h1>Pathfinding Visualiser</h1>
        <div class="wrapper">
          <form>
            <select name="algorithm" id="algorithm" class="btn select">
              <option value="Dijkstra">Algorithm: Dijkstra's</option>
              <option value="A*">Algorithm: A*</option>
              <option value="Floyd">Algorithm: Floyd-Warshall</option>
              <option value="BFS">Algorithm: BFS</option>
              <option value="DFS">Algorithm: DFS</option>
            </select>
          </form>
        </div>
        <div class="wrapper">
          <button id="wallButton" class="btn" onclick="wallEdit()">
            Create walls
          </button>
        </div>
        <div class="wrapper">
          <button class="startButton btn" onclick="start()">Start</button>
        </div>
        <div class="wrapper">
          <button class="refreshButton btn" onclick="refresh()">Refresh</button>
        </div>
        <div class="wrapper">
          <select id="speedBtn" class="btn select" onclick="assignSpeed()">
            <option value="slow">Speed: Slow</option>
            <option value="medium">Speed: Medium</option>
            <option value="fast">Speed: Fast</option>
          </select>
        </div>
        <div class="wrapper">
          <form>
            <select name="" id="weightButton" class="select btn">
              <option value="none">Heuristics: none</option>
              <option value="weak">Heuristics: Weak</option>
              <option value="medium">Heuristics: Medium</option>
              <option value="strong">Heuristics: Strong</option>
            </select>
          </form>
        </div>
      </nav>
      <div id="Grid"></div>
      <div>
        <div class="modal-intro modal active" data-page>
          <div class="modal-header">
            <button class="close-button" data-closeBtn>&times;</button>
            <div class="title">Introduction to Pathfinding Visualiser</div>
          </div>
          <div class="modal-body">
            <strong>What is this website?</strong><br /><br />
            This website is used to show how pathfinding algorithms function and
            their relative times to run, given the most efficient
            implementation.
            <br /><br />
            This is a short tutorial, to teach you how to utilise the
            pathfinding visualiser aswell as give a short background on each
            algorithm used.
            <br /><br />
            <a href="https://github.com/HasaanKH/VisualisingPathfinding.git"
              >Click here to check the source code!</a
            >
          </div>
          <div class="modal-footer">
            <button data-nextBtn class="btn">Next</button>
          </div>
        </div>
        <div class="modal-page2 modal" data-page>
          <div class="modal-header">
            <button class="close-button" data-closeBtn>&times;</button>
            <div class="title">Algorithms</div>
          </div>
          <div class="modal-body">
            <p>
              Dijkstra Algorithm: An algorithm to find the shortest path between
              a source node and any other node in the graph. The algorithm has a
              time complexity of O(E + VlogV) and gurantees the shortest path,
              only if the weights are >= 0.
            </p>
            <br />
            <p>
              A* algorithm: Similar to Dijkstra's algorithm, but considers
              heuristics in order to minimise the number of nodes needed to be
              searched. The algorithm gurantees the shortest path also in O(E +
              VlogV) time. Unlike Dijkstra, A* works with negative weights.
            </p>
            <br />
            <p>
              Floyd-Worshall Algorithm: This algorithm calculates the shortest
              distance between <strong><i>any 2 nodes.</i></strong> However, it
              has a much greater time complexity of O(V^3). This algorithm
              should not be run with large graphs. The algorithm works with
              negative values, but fails if there are any negative cycles.
            </p>
            <br />
            <p>
              Breadth-first search: This algorithm finds a path from the source
              node to the target node, by traversing a tree level by level until
              it reaches the target node. This algorithm does
              <strong><i>not gurantee</i></strong> the shortest path. The
              algorithm has a time complexity of O(n).
            </p>
            <br />
            Depth-first search: This algorithm behaves similarly to BFS.
            However, it instead traverses as far down the tree before
            backtracking until it find the target node. This does
            <strong><i>not gurantee</i> </strong>the shortest path. The
            algorithm also has a time complexity of O(n).
          </div>
          <div class="modal-footer">
            <button data-previousBtn class="btn">Previous</button>
            <button data-nextBtn class="btn">Next</button>
          </div>
        </div>
        <div class="modal-page3 modal" data-page>
          <div class="modal-header">
            <button class="close-button" data-closeBtn>&times;</button>
            <div class="title">Usage</div>
          </div>
          <div class="modal-body">
            Most of the buttons are self-explanatory, however there are a few
            notes to be made.<br /><br />
            <ul>
              <li>
                The buttons are not functional while the algorithms are being
                visualised.
              </li>
              <li>
                The create wall button, creates walls if you hold the mouse
                button down, and deletes walls by clicking on them. Once the
                refresh button is pressed, the walls are cleared.
              </li>
              <li>
                If the heuristic value is changed, the refresh button must be
                pressed in order to update the graph.
              </li>
              <li>
                If your viewport changes size, you must refresh the browser.
                Furthermore, if you have a particularly large viewport, it is
                not recommended to run the Floyd-Warshall Algorithm as it may
                cause the page to crash.
              </li>
            </ul>
          </div>
          <div class="modal-footer">
            <button data-previousBtn class="btn">Previous</button>
          </div>
        </div>
      </div>
      <div id="overlay" class="active"></div>
    </main>
  </body>
</html>
